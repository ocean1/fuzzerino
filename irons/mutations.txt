mutation list

===============================================
=== INSTRUCTIONS
===============================================

=== DONE:

ret (ReturnInst): operand
invoke (InvokeInst): args, result
resume (ResumeInst): operand
add, fadd, sub, fsub, mul, fmul, udiv, sdiv, fdiv, urem, srem, frem, shl, lshr, ashr, and, or, xor (BinaryOperator - treat everything the same):
    
    operands, result

load (LoadInst): ptr operand (no havoc or weird things)
getelementptr (GetElementPtrInst): indices operand(s) (no havoc or weird things)
store (StoreInst): operand, int/ptr/float

select (SelectInst): result
call (CallInst): args, result

=== TODO:

------------------------------------------------------------------------------
icmp (ICmpInst): result
fcmp (FCmpInst): result

<result> = icmp <cond> <ty> <op1>, <op2>   ; yields i1 or <N x i1>:result
------------------------------------------------------------------------------

extractelement (ExtractElementInst): 2nd operand (index), result
insertelement (InsertElementInst): 2nd operand (index)
extractvalue (ExtractValueInst): index/indices ( ? ), result
insertvalue (InsertValueInst): index/indices ( ? ), result
cmpxchg (AtomicCmpXchgInst): operand 2,3
atomicrmw (AtomicRMWInst): operand 1,3

=== BLACKLIST:

phi (PHINode): no - weird translation to machine code, not really compatible with queue

casts: no - it's probably there for a reason

===============================================
=== TYPES
===============================================

integer: -1, +1, substitute with -1, 0, 1, extreme value depending on bitwidth (fffffff...)
pointer: -1, +1, -2, +2, -4, +4, -8, +8
fp:      coming soon

===============================================
=== MUTATION MAP
===============================================

--- integer

0000 0000 0000 0001: KEEP_ORIGINAL

0000 0000 0000 0010: PLUS_ONE
0000 0000 0000 0100: MINUS_ONE

0000 0000 0000 1000: INTERESTING_1 (16, -129, -32769)
0000 0000 0001 0000: INTERESTING_2 (32, 128, 32768)
0000 0000 0010 0000: INTERESTING_3 (64, 255, 65535)
0000 0000 0100 0000: INTERESTING_4 (100, 256, 65536)
0000 0000 1000 0000: INTERESTING_5 (n/a, 512, n/a)
0000 0001 0000 0000: INTERESTING_6 (n/a, 1000, n/a)
0000 0010 0000 0000: INTERESTING_7 (n/a, 1024, n/a)
0000 0100 0000 0000: INTERESTING_8 (n/a, 4096, n/a)

(if instruction is not a GEP:)

0000 1000 0000 0000: PLUS_MAX
0001 0000 0000 0000: PLUS_RAND

0010 0000 0000 0000: RESERVED_1
0100 0000 0000 0000: RESERVED_2
1000 0000 0000 0000: RESERVED_3

--- pointer

0000 0000 0000 0001: KEEP_ORIGINAL
0000 0000 0000 0010: PLUS_ONE
0000 0000 0000 0100: MINUS_ONE
0000 0000 0000 1000: PLUS_TWO
0000 0000 0001 0000: MINUS_TWO
0000 0000 0010 0000: PLUS_FOUR
0000 0000 0100 0000: MINUS_FOUR
0000 0000 1000 0000: PLUS_EIGHT
0000 0001 0000 0000: MINUS_EIGHT

--- TODO

create simple whitelist-based heuristic for pointers

argue that with integers we already cover most of the fuzzing
by fuzzing GEP indices...

otherwise there are just too many segfaults

else we can write a smarter "queue" algorithm that is good at
detecting when a certain location segfaults most of the time and then
"turn it off", but it's not really nice

OR: act on the pointed buffer, but then we would need to
know at least its length - probably not possible in LLVM IR?

--- fp

coming soon